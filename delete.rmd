
```{r}
randtree <- ape::rcoal(100)
db <- data.frame(
  Category = sample(0:1, size = 89, replace = TRUE),
  label = randtree$tip.label[1:89])
data<- setNames(db$Category, db$label)


phyEstimateDiscfaux(trait = data, phy=randtree)


```
```{r}
phyEstimateDiscfaux <- function(phy, trait, best.state=TRUE, cutoff= 0.5, ...) {

  #trait should be a data.frame or vector with names matching phylogeny
  if (is.vector(trait)|is.factor(trait)) {
    trait <- data.frame(trait)
  }

  trait[,1] <- factor(trait[,1])
  trait.orig <- trait

  #given a tree with a novel taxa on it (taxa with no trait value)
  sppObs <- row.names(trait)
  sppUnobs <- phy$tip.label[!(phy$tip.label %in% sppObs)]
  trtlevels <- levels(trait[,1])
  res <- as.data.frame(matrix(nrow=length(sppUnobs), ncol=length(trtlevels), dimnames=list(sppUnobs, trtlevels)))

  #estimate support for different states for each novel taxon
  for (i in sppUnobs) {

    #for each novel species, prune all but measured + that species
    tree <- drop.tip(phy, subset(sppUnobs, sppUnobs != i))

    #root the tree at the novel species (leave root as trichotomy)
    tree <- root(tree, i, resolve.root=FALSE)


    #prune novel species and match new pruned tree <-> trait data
    tree <- drop.tip(tree, i)
    trait <- trait.orig[tree$tip.label,]

    #calculate value at root node and impute to novel species
    est <- ace(trait, tree, type="discrete", ...)
    val <- est$lik.anc[1,]
    res[i,] <- val
  }

  #estimate the best-supported state for each taxon
  if (best.state) {
    beststate <- as.data.frame(matrix(nrow=dim(res)[1], ncol=2))
    colnames(beststate) <- c("estimated.state","estimated.state.support")
    rownames(beststate) <- rownames(res)
    print(rownames(res))

    for (i in 1:dim(res)[1]) {
      #if >=cutoff % taxa have same label assign a consensus taxon to node
     # best <- -sort(-(res[i,]))[1]
      best <- -sort(-unlist(res[i,]))[1]

      if (best >= cutoff && !is.na(best)) {
        beststate[i,1] <- names(best)
        beststate[i,2] <- best
      }
      else
      {
        beststate[i,1] <- NA
        beststate[i,2] <- NA
      }
    }
  }

  #return the output
  if (best.state) {
    return(cbind(as.matrix(res),beststate))
  } else {
    return(as.matrix(res))
  }

}


```
