##' Phylogenetic Bipartite Linear Model
##' 
##' Fits a linear model to the association strengths of a bipartite data set
##' with or without phylogenetic correlation among the interacting species
##' 
##' Fit a linear model with covariates using estimated generalized least
##' squares to the association strengths between two sets of interacting
##' species.  Associations can be either binary or continuous. If phylogenies
##' of the two sets of interacting species are supplied, two \emph{phyogenetic
##' signal strength} parameters (\emph{d1} and \emph{d2}), one for each species
##' set, based on an Ornstein-Uhlenbeck model of evolution with stabilizing
##' selection are estimated. Values of \emph{d=1} indicate no stabilizing
##' selection and correspond to the Brownian motion model of evolution;
##' \emph{0<d<1} represents stabilizing selection; \emph{d=0} depicts the
##' absence of phylogenetic correlation (i.e., a star phylogeny); and
##' \emph{d>1} corresponds to disruptive selection where phylogenetic signal is
##' amplified. Confidence intervals for these and the other parameters can be
##' estimated with bootstrapping.  \cr \cr The function \code{pblmpredict}
##' predicts the associations of novel species following the methods given in
##' appendix B of Ives and Godfray (2006).
##' 
##' @aliases pblm pblmpredict
##' @param assocs A matrix of association strengths among two sets of
##' interacting species
##' @param tree1 A phylo tree object or a phylogenetic covariance matrix for
##' the rows of \code{assocs}
##' @param tree2 A phylo tree object or a phylogenetic covariance matrix for
##' the columns of \code{assocs}
##' @param covars1 A matrix of covariates (e.g., traits) for the row species of
##' \code{assocs}
##' @param covars2 A matrix of covariates (e.g., traits) for the column species
##' of \code{assocs}
##' @param bootstrap logical, bootstrap confidence intervals of the parameter
##' estimates
##' @param nreps Number of bootstrap replicated data sets to estimate parameter
##' CIs
##' @param maxit as in \code{\link{optim}}
##' @param pstart starting values of the two phylogenetic signal strength
##' parameters passed to \code{\link{optim}}
##' @return \item{MSE}{ total, full (each \emph{d} estimated), star
##' (\emph{d=0}), and base (\emph{d=1}) mean squared errors }
##' \item{signal.strength}{ two estimates of phylogenetic signal strength }
##' \item{coefficients}{ estimated intercept and covariate coefficients with
##' approximate 95 percent CIs for the three model types (full, star, base) }
##' \item{CI.boot}{ 95 percent CIs for all parameters } \item{variates}{ matrix
##' of model variates (can be used for plotting) } \item{residuals}{ matrix of
##' residuals from the three models (full, star and base) } \item{predicted}{
##' predicted associations } \item{bootvalues}{ matrix of parameters estimated
##' from the \code{nreps} bootstrap replicated data sets used to calculate CIs
##' } \item{phylocovs}{ phylogenetic covariance matricies scaled by the
##' estimated \code{d1} and \code{d2} } \item{cors.1}{ correlations among
##' predicted and observed associations for species of \code{tree1}, \code{NA}
##' if \code{predict.originals=FALSE} } \item{cors.2}{ correlations among
##' predicted and observed associations for species of \code{tree2}, \code{NA}
##' if \code{predict.originals=FALSE} } \item{pred.novels1}{ predicted
##' associations for the novel speices of \code{tree1} } \item{pred.novels2}{
##' predicted associations for the novel speices of \code{tree2} }
##' @note Covariates that apply to both species sets (e.g., sampling site)
##' should be supplied in the covariate matrix of the set with the most
##' species. \cr \cr Bootstrapping CIs is slow due to the function
##' \code{\link{optim}} used to estimate the model parameters. See appendix A
##' in Ives and Godfray (2006) for a discussion about this boostrapping
##' procedure \cr \cr If \code{pblmpredict=TRUE} the function does not first
##' remove each species in turn when predicting the associations of the
##' original species as is done in Ives and Godfray (2006).
##' @author Matthew Helmus \email{mrhelmus@@gmail.com}
##' @references Ives A.R. & Godfray H.C. (2006) Phylogenetic analysis of
##' trophic associations. The American Naturalist, 168, E1-E14 \cr \cr Blomberg
##' S.P., Garland T.J. & Ives A.R. (2003) Testing for phylogenetic signal in
##' comparative data: Behavioral traits are more labile. Evolution, 57, 717-745
##' @keywords univar
##' @examples
##' 
##' \donttest{
##' #load example data from Ives & Godfray (2006)
##' data(IvesGodfray)
##' 
##' #net attack rate of parasitoid on host eq.4 in Ives and Godfray
##' A<-(-1*log(1-IvesGodfray$interactions[,-28]/t(IvesGodfray$interactions[28])))
##' 
##' # Make tips of the phylogenetic trees contemporaneous by extending tips
##' p<-dim(IvesGodfray$host)[1]
##' q<-dim(IvesGodfray$parasitoid)[1]
##' host.cov.scaled<-IvesGodfray$host
##' para.cov.scaled<-IvesGodfray$parasitoid
##' for (i in 1:p)
##' {
##'   host.cov.scaled[i,i]<-max(host.cov.scaled)
##' }
##' for (i in 1:q)
##' {
##'   para.cov.scaled[i,i]<-max(para.cov.scaled)
##' }
##' 
##' # scale covariance matrices (this reduces numerical problems caused by
##' # determinants going to infinity or zero)
##'   host.cov.scaled<-host.cov.scaled/(det(as.matrix(host.cov.scaled))^(1/p))
##'   para.cov.scaled<-para.cov.scaled/(det(as.matrix(para.cov.scaled))^(1/q))
##' 
##' pblm.A <- pblm(sqrt(A),tree1=host.cov.scaled,tree2=para.cov.scaled)
##' pblm.A$signal.strength    #compare to Ives and Godfray (2006) Table 1 Line 1
##' pblm.A$MSE
##' }
##' 
##' @export pblm
pblm <- function(assocs, tree1 = NULL, tree2 = NULL, covars1 = NULL, covars2 = NULL, bootstrap = FALSE, nreps = 10, maxit = 10000, pstart = c(.5, .5)) {
  # Make a vector of associations
  A <- as.matrix(as.vector(as.matrix(assocs)))
  data.vecs <- A

  # numbers of species and interactions
  nassocs <- length(A)
  nspp1 <- dim(assocs)[1]
  nspp2 <- dim(assocs)[2]
  sppnames1 <- rownames(assocs)
  sppnames2 <- colnames(assocs)
  # make names of species pairs
  pairnames <- NULL # make a vector of pairwise comparison names
  for (o in 1:(nspp2))
  {
    for (u in 1:nspp1)
    {
      pairnames <- c(pairnames, paste(sppnames2[o], sppnames1[u], sep = "-"))
    }
  }

  # Clean Covariates
  # If the covariate applies to both sets, then it should be in the matrix of the longer set
  covnames <- NULL
  C1covs <- NULL
  if (is.null(covars1)) {
    C1 <- NULL
  } else {
    if (is.null(dim(covars1))) {
      C1 <- matrix(covars1, nspp1, nspp2, byrow = FALSE)
      if (is.factor(covars1)) {
        C1 <- as.matrix(as.vector(C1))
        C1covs <- cbind(C1covs, C1)
        C1 <- as.matrix(model.matrix(~ as.factor(C1) - 1)[, -1])
        colnames(C1) <- paste(rep("covar1", length(levels(covars1)) - 1), levels(covars1)[-1], sep = "-")
      } else {
        C1 <- as.matrix(as.vector(C1))
        C1covs <- cbind(C1covs, C1)
      }
      covnames <- c(covnames, "covar1")
    } else {
      C1 <- NULL
      for (i in 1:dim(covars1)[2])
      {
        C1hold <- matrix(covars1[, i], nspp1, nspp2, byrow = FALSE)
        if (is.factor(covars1[, i])) {
          C1hold <- as.matrix(as.vector(C1hold))
          C1covs <- cbind(C1covs, C1hold)
          C1hold <- as.matrix(model.matrix(~ as.factor(C1hold) - 1)[, -1])
          colnames(C1hold) <- paste(rep(colnames(covars1)[i], length(levels(covars1[, i])) - 1), levels(covars1[, i])[-1], sep = "-")
          C1 <- cbind(C1, C1hold)
        } else {
          C1hold <- as.matrix(as.vector(C1hold))
          C1covs <- cbind(C1covs, C1hold)
          colnames(C1hold) <- colnames(covars1)[i]
          C1 <- cbind(C1, C1hold)
        }
        covnames <- c(covnames, colnames(covars1)[i])
      }
    }

    data.vecs <- cbind(data.vecs, C1covs)
  }


  C2covs <- NULL
  if (is.null(covars2)) {
    C2 <- NULL
  } else {
    if (is.null(dim(covars2))) {
      C2 <- matrix(covars2, nspp1, nspp2, byrow = TRUE)
      if (is.factor(covars2)) {
        C2 <- as.matrix(as.vector(C2))
        C2covs <- cbind(C2covs, C2)
        C2 <- as.matrix(model.matrix(~ as.factor(C2) - 1)[, -1])
        colnames(C2) <- paste(rep("covar2", length(levels(covars2)) - 1), levels(covars2)[-1], sep = "-")
      } else {
        C2 <- as.matrix(as.vector(C2))
        C2covs <- cbind(C2covs, C2)
      }
      covnames <- c(covnames, "covar2")
    } else {
      C2 <- NULL
      for (i in 1:dim(covars2)[2])
      {
        C2hold <- matrix(covars2[, i], nspp1, nspp2, byrow = TRUE)
        if (is.factor(covars2[, i])) {
          C2hold <- as.matrix(as.vector(C2hold))
          C2covs <- cbind(C2covs, C2hold)
          C2hold <- as.matrix(model.matrix(~ as.factor(C2hold) - 1)[, -1])
          colnames(C2hold) <- paste(rep(colnames(covars2)[i], length(levels(covars2[, i])) - 1), levels(covars2[, i])[-1], sep = "-")
          C2 <- cbind(C2, C2hold)
        } else {
          C2hold <- as.matrix(as.vector(C2hold))
          C2covs <- cbind(C2covs, C2hold)
          colnames(C2hold) <- colnames(covars2)[i]
          C2 <- cbind(C2, C2hold)
        }
        covnames <- c(covnames, colnames(covars2)[i])
      }
    }

    data.vecs <- cbind(data.vecs, C2covs)
  }


  # Make U, the combined matrix of covariates
  U <- NULL
  if (is.null(C1) & is.null(C2)) {
    U <- rep(1, length(A))
  } else {
    if (is.null(C1)) {
      U <- rep(1, length(A))
    } else {
      U <- cbind(rep(1, length(A)), C1)
    }

    if (is.null(C2)) {
      U <- U
    } else {
      U <- cbind(U, C2)
    }
  }

  # Begin to organize output
  if (is.null(dim(U))) {
    data.vecs <- data.frame(A)
    colnames(data.vecs) <- "associations"
  } else {
    colnames(data.vecs) <- c("associations", covnames)
  }
  rownames(data.vecs) <- pairnames

  ######
  # Calculate Star Regression Coefficients
  # calculate for the star (assuming no phylogenetic correlation)
  astar <- solve((t(U) %*% U), (t(U) %*% A))
  MSETotal <- cov(A)
  s2aStar <- as.vector(MSETotal) * qr.solve((t(U) %*% U))
  sdaStar <- t(diag(s2aStar)^(.5))
  approxCFstar <- rbind(t(astar) - 1.96 %*% sdaStar, t(astar), t(astar) + 1.96 %*% sdaStar)
  Pstar <- U %*% astar
  Estar <- A - Pstar
  MSEStar <- cov(matrix(Estar))

  #######
  if (is.null(tree1) | is.null(tree2)) {
    coefs <- approxCFstar
    rownames(coefs) <- c("lower CI 95%", "estimate", "upper CI 95%")
    colnames(coefs) <- paste("star", c("intercept", colnames(U)[-1]), sep = "-")
    MSEs <- cbind(data.frame(MSETotal), data.frame(MSEStar))
    Pstar <- data.frame(Pstar)
    colnames(Pstar) <- "star"
    Estar <- data.frame(Estar)
    colnames(Estar) <- "star"
    output <- list(MSE = MSEs, signal.strength = NULL, coefficients = data.frame(t(coefs)), CI.boot = NULL, variates = data.frame(data.vecs), residuals = Estar, predicted = Pstar, bootvalues = NULL, Vfull = NULL)
    class(output) <- "pblm"
    return(output)
  } else {
    # tree1 is the phylogeny for the rows
    # tree2 is the phylogeny for the columns

    # Clean Trees
    if (is(tree1)[1] == "phylo") {
      if (is.null(tree1$edge.length)) {
        tree1 <- compute.brlen(tree1, 1)
      } # If phylo has no given branch lengths
      V1 <- vcv.phylo(tree1, corr = TRUE)
      V1 <- V1[rownames(assocs), rownames(assocs)]
    } else {
      V1 <- tree1[rownames(assocs), rownames(assocs)]
    }

    if (is(tree2)[1] == "phylo") {
      if (is.null(tree2$edge.length)) {
        tree2 <- compute.brlen(tree2, 1)
      } # If phylo has no given branch lengths
      V2 <- vcv.phylo(tree2, corr = TRUE)
      V2 <- V2[colnames(assocs), colnames(assocs)]
    } else {
      V2 <- tree2[colnames(assocs), colnames(assocs)]
    }

    # Calculate Regression Coefficents for the base (assuming strict brownian motion evolution, ds=1)
    V1 <- as.matrix(V1)
    V2 <- as.matrix(V2)

    V1 <- V1 / det(V1)^(1 / nspp1) # scale covariance matrices (this reduces numerical problems caused by
    V2 <- V2 / det(V2)^(1 / nspp2) # determinants going to infinity or zero)
    V <- kronecker(V2, V1)
    invV <- qr.solve(V)

    abase <- solve((t(U) %*% invV %*% U), ((t(U) %*% invV %*% A))) # NOTE: Ives in his Matlab code uses a Left matrix division symbol (\)
    MSEBase <- (t(A - U %*% abase) %*% invV %*% (A - U %*% abase)) / (nassocs - 1)
    s2abase <- as.vector(MSEBase) * qr.solve(t(U) %*% invV %*% U)
    sdabase <- t(diag(s2abase)^(.5))
    approxCFbase <- rbind(t(abase) - 1.96 %*% sdabase, t(abase), t(abase) + 1.96 %*% sdabase)
    Pbase <- t(t(U %*% abase) %*% invV)
    Ebase <- A - Pbase

    ###################
    # Full EGLS estimates of phylogenetic signal
    ##################
    initV1 <- V1
    initV2 <- V2

    # tau = tau_i + tau_j where tau_i equals the node to tip distance
    tau1 <- matrix(diag(initV1), nspp1, nspp1) + matrix(diag(initV1), nspp1, nspp1) - 2 * initV1
    tau2 <- matrix(diag(initV2), nspp2, nspp2) + matrix(diag(initV2), nspp2, nspp2) - 2 * initV2

    # The workhorse function to estimate ds
    pegls <- function(parameters) {
      d1 <- abs(parameters[1])
      d2 <- abs(parameters[2])

      V1 <- (d1^tau1) * (1 - d1^(2 * initV1)) / (1 - d1^2)
      V2 <- (d2^tau2) * (1 - d2^(2 * initV2)) / (1 - d2^2)

      V1 <- V1 / det(V1)^(1 / nspp1) # model of coevolution
      V2 <- V2 / det(V2)^(1 / nspp2)
      V <- kronecker(V2, V1)
      invV <- qr.solve(V)

      a <- solve((t(U) %*% invV %*% U), ((t(U) %*% invV %*% A))) # NOTE: Ives in his Matlab code uses a Left matrix division symbol (\)
      E <- (A - U %*% a)
      # MSE
      t(E) %*% invV %*% E / (nassocs - 1)
    }
    # estimate d1 and d2 via Nelder-Mead method same as fminsearch in Matlab, by minimizing MSE
    est <- optim(pstart, pegls, control = list(maxit = maxit))
    MSEFull <- est$value
    d1 <- abs(est$par[1])
    d2 <- abs(est$par[2])


    # Calculate EGLS coef w estimated ds
    V1 <- (d1^tau1) * (1 - d1^(2 * initV1)) / (1 - d1^2)
    V2 <- (d2^tau2) * (1 - d2^(2 * initV2)) / (1 - d2^2)
    V1 <- V1 / det(V1)^(1 / nspp1) # model of coevolution
    V2 <- V2 / det(V2)^(1 / nspp2)
    V <- kronecker(V2, V1)
    invV <- qr.solve(V)
    aFull <- solve((t(U) %*% invV %*% U), ((t(U) %*% invV %*% A))) # NOTE: Ives in his Matlab code uses a Left matrix division symbol (\)
    s2aFull <- as.vector(MSEFull) * qr.solve(t(U) %*% invV %*% U)
    sdaFull <- t(diag(s2aFull)^(.5))
    approxCFfull <- rbind(t(aFull) - 1.96 %*% sdaFull, t(aFull), t(aFull) + 1.96 %*% sdaFull)
    Pfull <- t(t(U %*% aFull) %*% invV)
    Efull <- A - Pfull

    ########################################

    # organize output
    coefs <- cbind(approxCFfull, approxCFstar, approxCFbase)
    rownames(coefs) <- c("approx lower CI 95%", "estimate", "approx upper CI 95%")
    colnames(coefs) <- c(paste("full", c("intercept", colnames(U)[-1]), sep = "-"), paste("star", c("intercept", colnames(U)[-1]), sep = "-"), paste("base", c("intercept", colnames(U)[-1]), sep = "-"))
    coefs <- t(coefs)
    CI.boot <- NULL
    MSEs <- cbind(data.frame(MSETotal), data.frame(MSEFull), data.frame(MSEStar), data.frame(MSEBase))
    residuals <- cbind(data.frame(Efull), data.frame(Estar), data.frame(Ebase))
    predicted <- cbind(data.frame(Pfull), data.frame(Pstar), data.frame(Pbase))
    rownames(residuals) <- pairnames
    rownames(predicted) <- pairnames
    colnames(predicted) <- c("full", "star", "base")
    colnames(residuals) <- c("full", "star", "base")
    phylocovs <- list(V1 = V1, V2 = V2)

    ################
    # bootstrap CIs
    if (bootstrap) {
      Vtrue <- V
      Atrue <- A
      atrue <- aFull
      dtrue <- c(d1, d2)
      ehold <- eigen(Vtrue, symmetric = TRUE)
      L <- ehold$vectors[, nassocs:1] # A or L
      G <- sort(ehold$values) # D
      iG <- diag(G^-.5) # iD

      # Construct Y = TT*A so that
      # E{(Y-b)*(Y-b)'} = E{(TT*A-b)*(TT*A-b)'}
      # 				  = T*V*T'
      # 				  = I

      TT <- iG %*% t(L)
      Y <- TT %*% Atrue
      Z <- TT %*% U

      res <- (Y - Z %*% atrue) # residuals in orthogonalized space
      invT <- qr.solve(TT)

      bootlist <- NULL
      for (i in 1:nreps)
      {
        randindex <- sample(1:nassocs, replace = TRUE) # vector of random indices
        # randindex=1:nassocs					# retain order
        YY <- Z %*% atrue + res[randindex] # create new values of Y with random residuals
        A <- invT %*% YY # back-transformed data
        pstart <- dtrue + c(0, .1)
        estRand <- optim(pstart, pegls, control = list(maxit = maxit))
        MSEFullrand <- estRand$value
        d1rand <- abs(estRand$par[1])
        d2rand <- abs(estRand$par[2])

        # Calculate EGLS coef w estimated ds
        V1 <- (d1rand^tau1) * (1 - d1rand^(2 * initV1)) / (1 - d1rand^2)
        V2 <- (d2rand^tau2) * (1 - d2rand^(2 * initV2)) / (1 - d2rand^2)
        V1 <- V1 / det(V1)^(1 / nspp1) # model of coevolution
        V2 <- V2 / det(V2)^(1 / nspp2)
        V <- kronecker(V2, V1)
        invV <- qr.solve(V)
        arand <- solve((t(U) %*% invV %*% U), ((t(U) %*% invV %*% A))) # NOTE: Ives in his Matlab code uses a Left matrix division symbol (\)

        bootlist <- rbind(bootlist, c(d1rand, d2rand, t(arand)))
      }
      nr <- dim(bootlist)[1]
      nc <- dim(bootlist)[2]

      # Calculate bootstrapped CIs
      alpha <- 0.05 # alpha is always 0.05, but could change here
      conf <- NULL
      for (j in 1:nc)
      {
        bootconf <- quantile(bootlist[, j], probs = c(alpha / 2, 1 - alpha / 2))
        conf <- rbind(conf, c(bootconf[1], bootconf[2]))
      }
      signal.strength <- data.frame(cbind(conf[1:2, 1], dtrue, conf[1:2, 2]))
      rownames(signal.strength) <- c("d1", "d2")
      colnames(signal.strength) <- c("booted lower CI 95%", "estimate", "booted upper CI 95%")

      # organize output
      CI.boot <- conf
      rownames(CI.boot) <- c("d1", "d2", "intercept", colnames(U)[-1])
      colnames(CI.boot) <- c("booted lower CI 95%", "booted upper CI 95%")
      colnames(bootlist) <- c("d1", "d2", "intercept", colnames(U)[-1])
      output <- list(MSE = MSEs, signal.strength = signal.strength, coefficients = data.frame(coefs), CI.boot = CI.boot, variates = data.frame(data.vecs), predicted = predicted, residuals = residuals, bootvalues = bootlist, phylocovs = phylocovs)
      class(output) <- "pblm"
      return(output)
    } else {
      ########
      # If bootstrapping not performed

      conf <- matrix(NA, 2, 2)
      signal.strength <- data.frame(cbind(conf[1, ], c(d1, d2), conf[2, ]))
      rownames(signal.strength) <- c("d1", "d2")
      colnames(signal.strength) <- c("booted lower CI 95%", "estimate", "booted upper CI 95%")
      output <- list(MSE = MSEs, signal.strength = signal.strength, coefficients = data.frame(coefs), CI.boot = NULL, variates = data.frame(data.vecs), predicted = predicted, residuals = residuals, bootvalues = NULL, phylocovs = phylocovs)
      class(output) <- "pblm"
      return(output)
    }
  }
}
